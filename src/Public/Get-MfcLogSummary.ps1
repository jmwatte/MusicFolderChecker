function Get-MfcLogSummary {
<#
.SYNOPSIS
    Analyzes and summarizes MusicFolderChecker JSONL log files, providing statistics and filtered views.

.DESCRIPTION
    Get-MfcLogSummary reads newline-delimited JSON (JSONL) log files generated by MusicFolderChecker functions
    and provides comprehensive summaries including counts by issue type, log level, and detailed entry information.

.PARAMETER LogPath
    Path to the JSONL log file to analyze. This parameter is mandatory.

.PARAMETER FilterIssueType
    Optional filter to show only entries with a specific issue type (e.g., 'MissingYear', 'MissingAlbumArtist').

.PARAMETER FilterLevel
    Optional filter to show only entries with a specific log level ('Info', 'Warning', 'Error').

.PARAMETER Output
    Specifies the output format. Valid values: 'Table' (default), 'JSON', 'CSV'.

.INPUTS
    None. This function does not accept pipeline input.

.OUTPUTS
    PSCustomObject, System.String, or CSV data depending on Output parameter.
    Default output includes LogPath, TotalEntries, ByIssueType, ByLevel, and Entries properties.

.EXAMPLE
    Get-MfcLogSummary -LogPath 'C:\Temp\mfc_run.jsonl'
    Analyzes the log file and displays a summary table with counts by issue type and level.

.EXAMPLE
    Get-MfcLogSummary -LogPath 'C:\Temp\mfc_run.jsonl' -FilterIssueType 'MissingYear'
    Shows only entries related to missing year metadata.

.EXAMPLE
    Get-MfcLogSummary -LogPath 'C:\Temp\mfc_run.jsonl' -Output JSON
    Returns the summary as a JSON string for further processing or saving.

.EXAMPLE
    Get-MfcLogSummary -LogPath 'C:\Temp\mfc_run.jsonl' -FilterLevel 'Error' -Output CSV
    Filters for error entries only and outputs as CSV format.

.NOTES
    Author: MusicFolderChecker Module
    The function gracefully handles malformed JSON lines by skipping them
    Use with log files generated by Update-MusicFolderMetadata and other module functions
#>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)] [string]$LogPath,
        [string]$FilterIssueType,
        [string]$FilterLevel,
        [ValidateSet('Table','JSON','CSV')][string]$Output = 'Table'
    )

    if (-not (Test-Path -LiteralPath $LogPath)) { throw "Log file not found: $LogPath" }

    $lines = Get-Content -LiteralPath $LogPath -ErrorAction Stop | Where-Object { $_ -match '\S' }
    $entries = @()
    foreach ($l in $lines) {
        try {
            $o = $l | ConvertFrom-Json -ErrorAction Stop
            $entries += $o
        }
        catch {
            # ignore lines that are not valid JSON
        }
    }

    if ($FilterIssueType) { $entries = $entries | Where-Object { $_.IssueType -eq $FilterIssueType } }
    if ($FilterLevel) { $entries = $entries | Where-Object { $_.Level -eq $FilterLevel } }

    # Build summary
    $byType = $entries | Group-Object -Property IssueType | ForEach-Object {
        [PSCustomObject]@{ IssueType = $_.Name; Count = $_.Count }
    }
    $byLevel = $entries | Group-Object -Property Level | ForEach-Object {
        [PSCustomObject]@{ Level = $_.Name; Count = $_.Count }
    }

    $result = [PSCustomObject]@{
        LogPath = $LogPath
        TotalEntries = $entries.Count
        ByIssueType = $byType
        ByLevel = $byLevel
        Entries = $entries
    }

    switch ($Output) {
        'JSON' { $result | ConvertTo-Json -Depth 5 }
        'CSV' { $result.ByIssueType | ConvertTo-Csv -NoTypeInformation }
        default { return $result }
    }
}
